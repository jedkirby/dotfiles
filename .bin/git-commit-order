#!/usr/bin/env perl

use strict;
use warnings;
use 5.010;

use Propeller::Git::Repo;
use Cwd qw(getcwd);
use File::Spec qw(rel2abs);

my $repo_name = $ARGV[2] // getcwd;

# pop repo name if supplied
splice @ARGV, 2;

@ARGV == 2 or die "Two commits are required";

my $repo = Propeller::Git::Repo->new(
	main_remote => File::Spec->rel2abs($repo_name)
);

my @order = $repo->commit_order(@ARGV);

if (@order) {
	say for @order;
	exit 0;
}
else {
	local $" = " and ";
	say STDERR "Commits @ARGV are divergent";
	exit 1;
}

__END__

=head1 NAME

git-commit-order - Return order of commits, oldest first

=head1 SYNOPSIS

I<git> I<commit-order> <tree-ish> <tree-ish> [<repo>]

=head1 DESCRIPTION

Provide two tree-ish tokens, e.g. branches or SHA1s, and the earliest commit
will be printed first, followed by the latest. Use cwd as the repo, or provide
a path to the repository to test.

If the commits are divergent, say so on STDERR and exit with status code 1.

=head1 EXAMPLES

B<Print the earliest and then the latest of 4691d86 and 724f040 in PropShop>

  $ git commit-order 4691d86 724f040 fuel/packages/propshop/
  724f040
  4691d86

B<Try to determine which of 4691d86 and e914dd9 is earlier, but they are not on the same branch>

  $ git commit-order 4691d86 e914dd9 fuel/packages/propshop/
  Commits 4691d86 e914dd9 are divergent
  $ echo $?
  1

