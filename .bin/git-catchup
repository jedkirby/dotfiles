#!/usr/bin/env perl

use strict;
use warnings;
use 5.010;

use Opt::Imistic;
use Term::ReadLine;

my $branch = shift;
my $remote = shift;

chomp(my ($current_branch) = grep {s/^\*\s+//} `git branch`);

$branch //= $current_branch;

{
	no warnings 'uninitialized';
	chomp $current_branch;
	if ($current_branch eq $branch and not $ARGV{f}) {
		`git ff`;
		exit;
	}
}

unless ($remote) {
	chomp(my @branches = `git branch -r | grep /$branch\$`);

	s/\s+//g for @branches;

	if (@branches > 1) {
		my @remotes;

		{
			my %remotes = map { (split m{/})[0] => 1 } @branches;
			@remotes = sort keys %remotes;
		}

		# It is possible that none of the branches was of the format remote/master
		if (! @remotes) {
			die "No remote found for $branch\nTry git catchup BRANCH TARGET\n";
		}
		if (@remotes == 1) {
			$remote = $remotes[0];
		}
		else {

			say 'Multiple remotes found. Please select.';

			my $i = 0;

			say $i++ . ". $_" for @remotes;

			my $term = Term::ReadLine->new('git-catchup');
			my $selection;

			{
				do {
					$selection = $term->readline;
					defined $remotes[$selection] and last;

					say "Fail less hard";
				} while not defined $selection;
			}

			$remote = $remotes[$selection] . '/' . $branch;
		}
	}
	else {
		$remote = $branches[0];
	}
}

die "Didn't find anything for $branch\n" if not $remote;

if ($current_branch eq $branch and $ARGV{f}) {
	my @hard = $ARGV{f} == 2 ? '--hard' : ();
	system(qw( git reset ), @hard, $remote);
}
else {
	system(qw(git branch -f), $branch, $remote);
}

__END__

=head1 NAME

git-catchup - Try to bring a local branch in line with its remote

=head1 SYNOPSIS

I<git catchup> [-f[f]] [<branch>] [<remote>]

=head1 DESCRIPTION

If not specified, <branch> will default to the current branch. A guess will be
made at which remote branch <branch> corresponds to, and puts it there if
possible. <remote> may be specified if it gets it wrong or can't determine.

If the branch is the current branch, a fast-forward will be attempted.
Otherwise the branch will simply be moved.

=head1 OPTIONS

=over 4

=item B<-f>

Force update, to override a non-fast-forward complaint. Repeat to hard-reset rather than mixed.

=back

=head1 EXAMPLES

B<Catch up current branch to remote (origin/branch)>

  $ git catchup

B<Catch up minor>

  $ git catchup minor

B<Force catchup, keeping working tree>

  $ git catchup
  fatal: Not possible to fast-forward, aborting.
  $ git catchup -f
  Unstaged changes after reset:
  M	classes/elasticsearch/index/product.php
  M	modules/category/bootstrap.php

B<Force catchup, discarding changes>

  $ git catchup
  fatal: Not possible to fast-forward, aborting.
  $ git catchup -ff
  HEAD is now at f4912af bugfix-category-admin-nav merged into minor; resolves #929

B<Tell it what remote to use>

  $ git catchup minor origin/minor
